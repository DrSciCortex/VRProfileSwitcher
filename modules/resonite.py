"""
Resonite Module
Manages Resonite account credentials, session tokens, and game settings.

Actual data directory (Windows):
  %USERPROFILE%/AppData/LocalLow/Yellow Dog Man Studios/Resonite/

Real directory contents (confirmed from user's machine):
  Data.litedb       -- main local database (settings, credentials, cached data)
  Data-log.litedb   -- LiteDB write-ahead log (pair with Data.litedb)
  Data.version      -- database version marker
  LocalKey.bin      -- local encryption key (ties account to this machine)
  LocalStorage/     -- locally stored assets and user data
  Assets/           -- cached assets

What we save:
  Data.litedb       -- contains login session/credentials and all settings
  Data-log.litedb   -- must be saved together with Data.litedb (WAL pair)
  Data.version      -- version file
  LocalKey.bin      -- local key (needed for auth; machine-specific)
  LocalStorage/     -- user's local inventory and data

What we skip:
  Assets/           -- large cache, safely regenerated by Resonite
  Player.log        -- log files, not config
  Corrupted*/       -- corrupted database recovery folders, not needed
  Instance.lock     -- runtime lock file, must not be copied

SECURITY NOTE: Data.litedb and LocalKey.bin together enable auto-login.
Keep your profile directories secure.
"""

from __future__ import annotations
import os
import json
import shutil
import logging
from pathlib import Path
from core.module_base import VRModule, ModuleStatus

logger = logging.getLogger(__name__)

# Files to save (in the base Resonite data dir)
SAVE_FILES = [
    "Data.litedb",
    "Data-log.litedb",
    "Data.version",
    "LocalKey.bin",
]

# Directories to save
SAVE_DIRS = [
    "LocalStorage",
]

# Explicitly skip these (large or runtime-only)
SKIP_PATTERNS = {
    "Assets", "Instance.lock", "Player.log", "Player-prev.log",
}


def _resonite_base() -> Path:
    """
    Resonite stores data in AppData/LocalLow (confirmed from official wiki and user).
    Path: %USERPROFILE%/AppData/LocalLow/Yellow Dog Man Studios/Resonite
    """
    userprofile = os.environ.get("USERPROFILE", str(Path.home()))
    return Path(userprofile) / "AppData" / "LocalLow" / "Yellow Dog Man Studios" / "Resonite"


class ResoniteModule(VRModule):
    id = "resonite"
    display_name = "Resonite"
    icon = "ðŸŒ"
    description = "Resonite account session, credentials (Data.litedb + LocalKey.bin), and LocalStorage"

    def _base(self) -> Path:
        override = self.options.get("resonite_dir")
        if override:
            return Path(override)
        return _resonite_base()

    def get_config_paths(self) -> list[Path]:
        base = self._base()
        paths = [base / f for f in SAVE_FILES]
        paths += [base / d for d in SAVE_DIRS]
        return paths

    def get_process_names(self) -> list[str]:
        return ["resonite.exe", "resonite-headless.exe"]

    def get_status(self) -> ModuleStatus:
        import psutil
        pids = []
        try:
            for proc in psutil.process_iter(["pid", "name"]):
                name = (proc.info.get("name") or "").lower()
                if name in ("resonite.exe", "resonite-headless.exe"):
                    pids.append(proc.info["pid"])
        except Exception:
            pass
        base = self._base()
        return ModuleStatus(
            is_running=bool(pids),
            process_pids=pids,
            config_paths_exist=(base / "Data.litedb").exists(),
        )

    def backup(self, dest_dir: Path) -> tuple[bool, str]:
        base = self._base()
        if not base.exists():
            return False, f"Resonite data directory not found: {base}"

        module_dest = dest_dir / self.id
        module_dest.mkdir(parents=True, exist_ok=True)
        saved = []
        errors = []

        # Save individual files
        for fname in SAVE_FILES:
            src = base / fname
            if src.exists():
                try:
                    shutil.copy2(src, module_dest / fname)
                    saved.append(fname)
                except Exception as e:
                    errors.append(f"{fname}: {e}")
            else:
                logger.debug(f"[resonite] backup: {fname} not found, skipping")

        # Save directories
        for dname in SAVE_DIRS:
            src = base / dname
            if src.exists() and src.is_dir():
                dst = module_dest / dname
                try:
                    if dst.exists():
                        shutil.rmtree(dst)
                    shutil.copytree(src, dst)
                    size = sum(f.stat().st_size for f in dst.rglob("*") if f.is_file())
                    saved.append(f"{dname}/ ({size // 1024} KB)")
                except Exception as e:
                    errors.append(f"{dname}: {e}")

        if not saved:
            return False, "Nothing to back up â€” no Resonite data files found"

        msg = f"Backed up: {', '.join(saved)}"
        if errors:
            msg += f" | Errors: {'; '.join(errors)}"
        logger.info(f"[resonite] {msg}")
        return True, msg

    def restore(self, src_dir: Path) -> tuple[bool, str]:
        module_src = src_dir / self.id
        if not module_src.exists():
            return False, "No Resonite backup found in this profile"

        base = self._base()
        base.mkdir(parents=True, exist_ok=True)
        restored = []
        errors = []

        for fname in SAVE_FILES:
            src = module_src / fname
            if src.exists():
                try:
                    shutil.copy2(src, base / fname)
                    restored.append(fname)
                except Exception as e:
                    errors.append(f"{fname}: {e}")

        for dname in SAVE_DIRS:
            src = module_src / dname
            if src.exists():
                dst = base / dname
                try:
                    if dst.exists():
                        shutil.rmtree(dst)
                    shutil.copytree(src, dst)
                    restored.append(f"{dname}/")
                except Exception as e:
                    errors.append(f"{dname}: {e}")

        if not restored:
            return False, "Nothing restored"
        msg = f"Restored: {', '.join(restored)}"
        if errors:
            msg += f" | Errors: {'; '.join(errors)}"
        return True, msg

    def validate_backup(self, profile_dir: Path) -> tuple[bool, str]:
        module_src = profile_dir / self.id
        if not module_src.exists():
            return False, "No Resonite backup found in this profile"
        has_db = (module_src / "Data.litedb").exists()
        if not has_db:
            return False, "Backup is missing Data.litedb â€” may be incomplete"
        return True, "Resonite backup looks valid (Data.litedb present)"

    def can_reload_live(self) -> bool:
        return False
