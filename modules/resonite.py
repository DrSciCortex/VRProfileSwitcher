"""
Resonite Module
Manages Resonite account credentials, session tokens, and game settings.

Actual data directory (Windows):
  %USERPROFILE%/AppData/LocalLow/Yellow Dog Man Studios/Resonite/

Real directory contents (confirmed from user's machine):
  Data.litedb       -- main local database (settings, credentials, cached data)
  Data-log.litedb   -- LiteDB write-ahead log (pair with Data.litedb)
  Data.version      -- database version marker
  LocalKey.bin      -- local encryption key (ties account to this machine)
  LocalStorage/     -- locally stored assets and user data
  Assets/           -- cached assets

What we save:
  Data.litedb       -- contains login session/credentials and all settings
  Data-log.litedb   -- must be saved together with Data.litedb (WAL pair)
  Data.version      -- version file
  LocalKey.bin      -- local key (needed for auth; machine-specific)
  LocalStorage/     -- user's local inventory and data

What we skip:
  Assets/           -- large cache, safely regenerated by Resonite
  Player.log        -- log files, not config
  Corrupted*/       -- corrupted database recovery folders, not needed
  Instance.lock     -- runtime lock file, must not be copied

SECURITY NOTE: Data.litedb and LocalKey.bin together enable auto-login.
Keep your profile directories secure.
"""

from __future__ import annotations
import os
import json
import shutil
import logging
from pathlib import Path
from core.module_base import VRModule, ModuleStatus

logger = logging.getLogger(__name__)

# Files to save (in the base Resonite data dir)
# NOTE: Data-log.litedb is the LiteDB write-ahead log (WAL).
#   - On BACKUP: we save it alongside Data.litedb so the pair is consistent.
#   - On RESTORE: we do NOT copy it back. Instead we delete any existing WAL
#     so LiteDB starts with a clean "no uncommitted transactions" state.
#     Restoring a WAL from a different point-in-time than the main DB causes
#     LiteDB to see an inconsistency â†’ Resonite crashes â†’ wipes the database.
SAVE_FILES = [
    "Data.litedb",
    "Data-log.litedb",   # backed up for consistency, but NOT restored (see above)
    "Data.version",
    "LocalKey.bin",
]


# Directories to save
SAVE_DIRS = [
    "LocalStorage",
]

# Explicitly skip these (large or runtime-only)
SKIP_PATTERNS = {
    "Assets", "Instance.lock", "Player.log", "Player-prev.log",
}


def _resonite_base() -> Path:
    """
    Resonite stores data in AppData/LocalLow (confirmed from official wiki and user).
    Path: %USERPROFILE%/AppData/LocalLow/Yellow Dog Man Studios/Resonite
    """
    userprofile = os.environ.get("USERPROFILE", str(Path.home()))
    return Path(userprofile) / "AppData" / "LocalLow" / "Yellow Dog Man Studios" / "Resonite"


def _resonite_is_running() -> bool:
    """Return True if Resonite.exe is currently running."""
    try:
        import subprocess
        out = subprocess.check_output(
            ["tasklist", "/FI", "IMAGENAME eq Resonite.exe", "/NH"],
            stderr=subprocess.DEVNULL,
            creationflags=0x08000000,  # CREATE_NO_WINDOW
        ).decode(errors="ignore")
        return "Resonite.exe" in out
    except Exception:
        return False


class ResoniteModule(VRModule):
    id = "resonite"
    display_name = "Resonite"
    icon = "ðŸŒ"
    description = "Resonite account session, credentials (Data.litedb + LocalKey.bin), and LocalStorage"

    def _base(self) -> Path:
        override = self.options.get("resonite_dir")
        if override:
            return Path(override)
        return _resonite_base()

    def get_config_paths(self) -> list[Path]:
        base = self._base()
        paths = [base / f for f in SAVE_FILES]
        paths += [base / d for d in SAVE_DIRS]
        return paths

    def get_process_names(self) -> list[str]:
        return ["resonite.exe", "resonite-headless.exe"]

    def get_status(self) -> ModuleStatus:
        import psutil
        pids = []
        try:
            for proc in psutil.process_iter(["pid", "name"]):
                name = (proc.info.get("name") or "").lower()
                if name in ("resonite.exe", "resonite-headless.exe"):
                    pids.append(proc.info["pid"])
        except Exception:
            pass
        base = self._base()
        return ModuleStatus(
            is_running=bool(pids),
            process_pids=pids,
            config_paths_exist=(base / "Data.litedb").exists(),
        )

    def backup(self, dest_dir: Path) -> tuple[bool, str]:
        if _resonite_is_running():
            return False, (
                "Resonite is currently running. Close it before saving a profile â€” "
                "the LiteDB database may be mid-write and the backup would be unreliable."
            )
        base = self._base()
        if not base.exists():
            return False, f"Resonite data directory not found: {base}"

        module_dest = dest_dir / self.id
        module_dest.mkdir(parents=True, exist_ok=True)
        saved = []
        errors = []

        # Save individual files
        for fname in SAVE_FILES:
            src = base / fname
            if src.exists():
                try:
                    shutil.copy2(src, module_dest / fname)
                    saved.append(fname)
                except Exception as e:
                    errors.append(f"{fname}: {e}")
            else:
                logger.debug(f"[resonite] backup: {fname} not found, skipping")

        # Save directories
        for dname in SAVE_DIRS:
            src = base / dname
            if src.exists() and src.is_dir():
                dst = module_dest / dname
                try:
                    if dst.exists():
                        shutil.rmtree(dst)
                    shutil.copytree(src, dst)
                    size = sum(f.stat().st_size for f in dst.rglob("*") if f.is_file())
                    saved.append(f"{dname}/ ({size // 1024} KB)")
                except Exception as e:
                    errors.append(f"{dname}: {e}")

        if not saved:
            return False, "Nothing to back up â€” no Resonite data files found"

        msg = f"Backed up: {', '.join(saved)}"
        if errors:
            msg += f" | Errors: {'; '.join(errors)}"
        logger.info(f"[resonite] {msg}")
        return True, msg

    def restore(self, src_dir: Path) -> tuple[bool, str]:
        module_src = src_dir / self.id
        if not module_src.exists():
            return False, "No Resonite backup found in this profile"

        if _resonite_is_running():
            return False, (
                "Resonite is currently running. Close it before restoring a profile â€” "
                "restoring the database while Resonite holds a file lock will corrupt it."
            )

        base = self._base()
        base.mkdir(parents=True, exist_ok=True)
        restored = []
        errors = []

        # WAL handling: if the backup contains Data-log.litedb it was saved
        # together with Data.litedb while Resonite was closed (consistent pair),
        # so restore both normally. If the backup has no WAL, delete any existing
        # one on disk â€” a stale WAL from a different DB state would cause LiteDB
        # to see an inconsistency and Resonite to wipe the database.
        backup_has_wal = (module_src / "Data-log.litedb").exists()
        if not backup_has_wal:
            wal = base / "Data-log.litedb"
            if wal.exists():
                try:
                    wal.unlink()
                    logger.info("[resonite] Backup has no WAL â€” deleted existing Data-log.litedb to avoid DB mismatch")
                except Exception as e:
                    logger.warning(f"[resonite] Could not delete existing WAL: {e}")

        for fname in SAVE_FILES:
            src = module_src / fname
            if src.exists():
                try:
                    shutil.copy2(src, base / fname)
                    restored.append(fname)
                except Exception as e:
                    errors.append(f"{fname}: {e}")

        for dname in SAVE_DIRS:
            src = module_src / dname
            if src.exists():
                dst = base / dname
                try:
                    if dst.exists():
                        shutil.rmtree(dst)
                    shutil.copytree(src, dst)
                    restored.append(f"{dname}/")
                except Exception as e:
                    errors.append(f"{dname}: {e}")

        if not restored:
            return False, "Nothing restored"
        msg = f"Restored: {', '.join(restored)}"
        if errors:
            msg += f" | Errors: {'; '.join(errors)}"
        return True, msg

    def validate_backup(self, profile_dir: Path) -> tuple[bool, str]:
        module_src = profile_dir / self.id
        if not module_src.exists():
            return False, "No Resonite backup found in this profile"
        has_db = (module_src / "Data.litedb").exists()
        if not has_db:
            return False, "Backup is missing Data.litedb â€” may be incomplete"
        return True, "Resonite backup looks valid (Data.litedb present)"

    def can_reload_live(self) -> bool:
        return False
